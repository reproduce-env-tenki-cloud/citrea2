//! Defines the traits that must be implemented by zkVMs. A zkVM like Risc0 consists of two components,
//! a "guest" and a "host". The guest is the zkVM program itself, and the host is the physical machine on
//! which the zkVM is running. Both the guest and the host are required to implement the [`Zkvm`] trait, in
//! addition to the specialized [`ZkvmGuest`] and [`ZkvmHost`] trait which is appropriate to that environment.
//!
//! For a detailed example showing how to implement these traits, see the
//! [risc0 adapter](https://github.com/Sovereign-Labs/sovereign-sdk/tree/main/adapters/risc0)
//! maintained by the Sovereign Labs team.

extern crate alloc;

use alloc::collections::{BTreeMap, VecDeque};
use alloc::vec::Vec;
use core::convert::Into;
use core::fmt::Debug;

use borsh::{BorshDeserialize, BorshSerialize};
use serde::de::DeserializeOwned;
use serde::{Deserialize, Serialize};

use super::da::BlobReaderTrait;
use super::soft_confirmation::SignedSoftConfirmationV1;
use crate::da::{DaSpec, LatestDaState};
use crate::mmr::{MMRChunk, MMRGuest, MMRInclusionProof};
use crate::soft_confirmation::SignedSoftConfirmation;
use crate::spec::SpecId;

/// The ZK proof generated by the [`ZkvmHost::run`] method.
pub type Proof = Vec<u8>;

/// A trait implemented by the prover ("host") of a zkVM program.
pub trait ZkvmHost: Zkvm + Clone {
    /// The associated guest type
    type Guest: ZkvmGuest;
    /// Give the guest a piece of advice non-deterministically
    /// `item` is a borsh serialized input to the guest
    fn add_hint(&mut self, item: Vec<u8>);

    /// Simulate running the guest using the provided hints.
    ///
    /// Provides a simulated version of the guest which can be
    /// accessed in the current process.
    fn simulate_with_hints(&mut self) -> Self::Guest;

    /// Run the guest in the true zk environment using the provided hints.
    ///
    /// This runs the guest binary compiled for the zkVM target, optionally
    /// creating a SNARK of correct execution. Running the true guest binary comes
    /// with some mild performance overhead and is not as easy to debug as [`simulate_with_hints`](ZkvmHost::simulate_with_hints).
    fn run(
        &mut self,
        elf: Vec<u8>,
        with_proof: bool,
        is_post_genesis_batch: bool,
    ) -> Result<Proof, anyhow::Error>;

    /// Extracts public input and receipt from the proof.
    fn extract_output<T: BorshDeserialize>(proof: &Proof) -> Result<T, Self::Error>;

    /// Host recovers pending proving sessions and returns proving results
    fn recover_proving_sessions(&self) -> Result<Vec<Proof>, anyhow::Error>;

    /// Host adds an assumption to the proving session
    /// Assumptions are used for recursive proving
    fn add_assumption(&mut self, receipt_buf: Vec<u8>);
}

/// A Zk proof system capable of proving and verifying arbitrary Rust code
/// Must support recursive proofs.
pub trait Zkvm: Send + Sync {
    /// A commitment to the zkVM program which is being proven
    type CodeCommitment: Clone
        + Debug
        + Serialize
        + DeserializeOwned
        + From<[u32; 8]>
        + Into<[u32; 8]>
        + Send
        + Sync
        + 'static;

    /// The error type which is returned when a proof fails to verify
    type Error: Debug;

    /// Interpret a sequence of a bytes as a proof and attempt to verify it against the code commitment.
    /// If the proof is valid, return Ok, else Err.
    fn verify(
        serialized_proof: &[u8],
        code_commitment: &Self::CodeCommitment,
    ) -> Result<(), Self::Error>;

    /// Meant for guest implementations.
    /// zkVM systems like Risc0 only have efficient recursive verification if
    /// the proof is expected to pass.
    /// This method is to be implemented with regular verification APIs of the zkVM system.
    fn verify_expected_to_fail(
        serialized_proof: &[u8],
        code_commitment: &Self::CodeCommitment,
    ) -> Result<(), Self::Error>;

    /// Extracts the raw output without doing any verification.
    /// The raw output is usually called "journal" which is the serialized output of the zkVM program.
    fn extract_raw_output(serialized_proof: &[u8]) -> Result<Vec<u8>, Self::Error>;

    /// Deserialize the output from the proof.
    /// This is used to extract the output from the zkVM program.
    fn deserialize_output<T: BorshDeserialize>(journal: &[u8]) -> Result<T, Self::Error>;

    /// Same as [`verify`](Zkvm::verify), except that instead of returning the output
    /// as a serialized array, it returns a state transition structure.
    /// TODO: specify a deserializer for the output
    fn verify_and_deserialize_output<T: BorshDeserialize>(
        serialized_proof: &[u8],
        code_commitment: &Self::CodeCommitment,
    ) -> Result<T, Self::Error>;
}

/// A trait which is accessible from within a zkVM program.
pub trait ZkvmGuest: Zkvm + Send + Sync {
    /// Obtain "advice" non-deterministically from the host
    fn read_from_host<T: BorshDeserialize>(&self) -> T;
    /// Add a public output to the zkVM proof
    fn commit<T: BorshSerialize>(&self, item: &T);
}

/// State diff produced by the Zk proof
pub type CumulativeStateDiff = BTreeMap<Vec<u8>, Option<Vec<u8>>>;

/// Because we removed validity condition from everywhere we need to keep it for compatibility
#[derive(Clone, Debug, Serialize, Deserialize, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct OldChainValidityCondition {
    /// Prev hash
    pub prev_hash: [u8; 32],
    /// Block hash
    pub block_hash: [u8; 32],
}

/// The pre fork 1 batch proof circuit output
#[derive(Clone, Debug, Serialize, Deserialize, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct OldBatchProofCircuitOutput<Da: DaSpec, Root> {
    /// The state of the rollup before the transition
    pub initial_state_root: Root,
    /// The state of the rollup after the transition
    pub final_state_root: Root,
    /// The hash before the state transition
    pub initial_batch_hash: [u8; 32],
    /// State diff of L2 blocks in the processed sequencer commitments.
    pub state_diff: CumulativeStateDiff,
    /// The DA slot hash that the sequencer commitments causing this state transition were found in.
    pub da_slot_hash: Da::SlotHash,
    /// The range of sequencer commitments in the DA slot that were processed.
    /// The range is inclusive.
    pub sequencer_commitments_range: (u32, u32),
    /// Sequencer public key.
    pub sequencer_public_key: Vec<u8>,
    /// Sequencer DA public key.
    pub sequencer_da_public_key: Vec<u8>,
    /// An additional validity condition for the state transition which needs
    /// to be checked outside of the zkVM circuit. This typically corresponds to
    /// some claim about the DA layer history, such as (X) is a valid block on the DA layer
    /// This should be Da::ValidityCondition however we removed but we need to keep it for compatibility
    /// That's why we use OldChainValidityCondition instead of Da::ValidityCondition
    /// This is from old bitcoin da spec
    pub validity_condition: OldChainValidityCondition,
    /// The final spec id after state transition is completed.
    pub last_active_spec_id: SpecId,
    /// Pre-proven commitments L2 ranges which also exist in the current L1 `da_data`.
    pub preproven_commitments: Vec<usize>,
}

/// The public output of a SNARK batch proof in Sovereign, this struct makes a claim that
/// the state of the rollup has transitioned from `initial_state_root` to `final_state_root`
///
/// The period of time covered by a state transition proof is a range of L2 blocks whose sequencer
/// commitments are included in the DA slot with hash `da_slot_hash`. The range is inclusive.
/// Some fields (prev_soft_confirmation_hash, final_soft_confirmation_hash and last_l2_height)
/// Will be 0 for pre fork 1 proofs because this is a new output format and those fields
/// did not exist pre fork 1
#[derive(Clone, Debug, Serialize, Deserialize, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct BatchProofCircuitOutput<Da: DaSpec, Root> {
    /// The state of the rollup before the transition
    pub initial_state_root: Root,
    /// The state of the rollup after the transition
    pub final_state_root: Root,
    /// The hash of the last soft confirmation before the state transition
    /// This will be [0; 32] for pre fork 1 proofs
    pub prev_soft_confirmation_hash: [u8; 32],
    /// The hash of the last soft confirmation in the state transition
    /// This will be [0; 32] for pre fork 1 proofs
    pub final_soft_confirmation_hash: [u8; 32],
    /// State diff of L2 blocks in the processed sequencer commitments.
    pub state_diff: CumulativeStateDiff,
    /// The DA slot hash that the sequencer commitments causing this state transition were found in.
    pub da_slot_hash: Da::SlotHash,
    /// The range of sequencer commitments in the DA slot that were processed.
    /// The range is inclusive.
    pub sequencer_commitments_range: (u32, u32),
    /// Sequencer public key.
    pub sequencer_public_key: Vec<u8>,
    /// Sequencer DA public key.
    pub sequencer_da_public_key: Vec<u8>,
    /// The last processed l2 height in the processed sequencer commitments.
    /// This will be 0 for pre fork 1 proofs
    pub last_l2_height: u64,
    /// Pre-proven commitments L2 ranges which also exist in the current L1 `da_data`.
    pub preproven_commitments: Vec<usize>,
}

/// A trait expressing that two items of a type are (potentially fuzzy) matches.
/// We need a custom trait instead of relying on [`PartialEq`] because we allow fuzzy matches.
pub trait Matches<T> {
    /// Check if two items are a match
    fn matches(&self, other: &T) -> bool;
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
// Prevent serde from generating spurious trait bounds. The correct serde bounds are already enforced by the
// StateTransitionFunction, DA, and Zkvm traits.
#[serde(
    bound = "StateRoot: Serialize + DeserializeOwned, Witness: Serialize + DeserializeOwned, Tx: Serialize + DeserializeOwned"
)]
/// Data required to verify a state transition.
pub struct BatchProofCircuitInput<'txs, StateRoot, Witness, Da: DaSpec, Tx: Clone> {
    /// The state root before the state transition
    pub initial_state_root: StateRoot,
    /// The state root after the state transition
    pub final_state_root: StateRoot,
    /// The hash before the state transition
    pub prev_soft_confirmation_hash: [u8; 32],
    /// The `crate::da::DaData` that are being processed as blobs. Everything that's not `crate::da::DaData::SequencerCommitment` will be ignored.
    pub da_data: Vec<Da::BlobTransaction>,
    /// DA block header that the sequencer commitments were found in.
    pub da_block_header_of_commitments: Da::BlockHeader,
    /// The inclusion proof for all DA data.
    pub inclusion_proof: Da::InclusionMultiProof,
    /// The completeness proof for all DA data.
    pub completeness_proof: Da::CompletenessProof,
    /// Pre-proven commitments L2 ranges which also exist in the current L1 `da_data`.
    pub preproven_commitments: Vec<usize>,
    /// The soft confirmations that are inside the sequencer commitments.
    pub soft_confirmations: VecDeque<Vec<SignedSoftConfirmation<'txs, Tx>>>,
    /// Corresponding witness for the soft confirmations.
    pub state_transition_witnesses: VecDeque<Vec<(Witness, Witness)>>,
    /// DA block headers the soft confirmations was constructed on.
    pub da_block_headers_of_soft_confirmations: VecDeque<Vec<Da::BlockHeader>>,
    /// Sequencer soft confirmation public key.
    /// **DO NOT USE THIS FIELD IN POST FORK1 GUEST**
    pub sequencer_public_key: Vec<u8>,
    /// Sequencer DA public_key: Vec<u8>,
    /// **DO NOT USE THIS FIELD IN POST FORK1 GUEST**
    pub sequencer_da_public_key: Vec<u8>,
    /// The range of sequencer commitments that are being processed.
    /// The range is inclusive.
    pub sequencer_commitments_range: (u32, u32),
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
// Prevent serde from generating spurious trait bounds. The correct serde bounds are already enforced by the
// StateTransitionFunction, DA, and Zkvm traits.
#[serde(bound = "StateRoot: Serialize + DeserializeOwned")]
/// First part of the Kumquat elf input
pub struct BatchProofCircuitInputV2Part1<StateRoot, Da: DaSpec> {
    /// The state root before the state transition
    pub initial_state_root: StateRoot,
    /// The state root after the state transition
    pub final_state_root: StateRoot,
    /// The hash before the state transition
    pub prev_soft_confirmation_hash: [u8; 32],
    /// The `crate::da::DaData` that are being processed as blobs. Everything that's not `crate::da::DaData::SequencerCommitment` will be ignored.
    pub da_data: Vec<Da::BlobTransaction>,
    /// DA block header that the sequencer commitments were found in.
    pub da_block_header_of_commitments: Da::BlockHeader,
    /// The inclusion proof for all DA data.
    pub inclusion_proof: Da::InclusionMultiProof,
    /// The completeness proof for all DA data.
    pub completeness_proof: Da::CompletenessProof,
    /// Pre-proven commitments L2 ranges which also exist in the current L1 `da_data`.
    pub preproven_commitments: Vec<usize>,
    /// DA block headers the soft confirmations was constructed on.
    pub da_block_headers_of_soft_confirmations: VecDeque<Vec<Da::BlockHeader>>,
    /// The range of sequencer commitments that are being processed.
    /// The range is inclusive.
    pub sequencer_commitments_range: (u32, u32),
}

impl<'txs, StateRoot, Witness, Da, Tx> BatchProofCircuitInput<'txs, StateRoot, Witness, Da, Tx>
where
    Da: DaSpec,
    Tx: Clone,
    StateRoot: Serialize + DeserializeOwned,
    Witness: Serialize + DeserializeOwned,
{
    /// Into Kumquat expected inputs
    pub fn into_v2_parts(
        self,
    ) -> (
        BatchProofCircuitInputV2Part1<StateRoot, Da>,
        BatchProofCircuitInputV2Part2<'txs, Witness, Tx>,
    ) {
        assert_eq!(
            self.soft_confirmations.len(),
            self.state_transition_witnesses.len()
        );
        let mut x = VecDeque::with_capacity(self.soft_confirmations.len());

        for (confirmations, witnesses) in self
            .soft_confirmations
            .into_iter()
            .zip(self.state_transition_witnesses)
        {
            assert_eq!(confirmations.len(), witnesses.len());

            let v: Vec<_> = confirmations
                .into_iter()
                .zip(witnesses)
                .map(|(confirmation, (state_witness, offchain_witness))| {
                    (confirmation, state_witness, offchain_witness)
                })
                .collect();

            x.push_back(v);
        }

        (
            BatchProofCircuitInputV2Part1 {
                initial_state_root: self.initial_state_root,
                final_state_root: self.final_state_root,
                prev_soft_confirmation_hash: self.prev_soft_confirmation_hash,
                da_data: self.da_data,
                da_block_header_of_commitments: self.da_block_header_of_commitments,
                inclusion_proof: self.inclusion_proof,
                completeness_proof: self.completeness_proof,
                preproven_commitments: self.preproven_commitments,
                da_block_headers_of_soft_confirmations: self.da_block_headers_of_soft_confirmations,
                sequencer_commitments_range: self.sequencer_commitments_range,
            },
            BatchProofCircuitInputV2Part2(x),
        )
    }
}

#[derive(BorshDeserialize, BorshSerialize)]
/// Second part of the Kumquat elf input
/// This is going to be read per-need basis to not go out of memory
/// in the zkvm
pub struct BatchProofCircuitInputV2Part2<'txs, Witness, Tx: Clone>(
    VecDeque<Vec<(SignedSoftConfirmation<'txs, Tx>, Witness, Witness)>>,
);

#[derive(Serialize, Deserialize)]
// Prevent serde from generating spurious trait bounds. The correct serde bounds are already enforced by the
// StateTransitionFunction, DA, and Zkvm traits.
#[serde(bound = "StateRoot: Serialize + DeserializeOwned, Witness: Serialize + DeserializeOwned")]
/// Data required to verify a state transition.
pub struct BatchProofCircuitInputV1<StateRoot, Witness, Da: DaSpec> {
    /// The state root before the state transition
    pub initial_state_root: StateRoot,
    /// The state root after the state transition
    pub final_state_root: StateRoot,
    /// The hash before the state transition
    pub initial_batch_hash: [u8; 32],
    /// The `crate::da::DaData` that are being processed as blobs. Everything that's not `crate::da::DaData::SequencerCommitment` will be ignored.
    pub da_data: Vec<Da::BlobTransaction>,
    /// DA block header that the sequencer commitments were found in.
    pub da_block_header_of_commitments: Da::BlockHeader,
    /// The inclusion proof for all DA data.
    pub inclusion_proof: Da::InclusionMultiProof,
    /// The completeness proof for all DA data.
    pub completeness_proof: Da::CompletenessProof,
    /// Pre-proven commitments L2 ranges which also exist in the current L1 `da_data`.
    pub preproven_commitments: Vec<usize>,
    /// The soft confirmations that are inside the sequencer commitments.
    pub soft_confirmations: VecDeque<Vec<SignedSoftConfirmationV1>>,
    /// Corresponding witness for the soft confirmations.
    pub state_transition_witnesses: VecDeque<Vec<Witness>>,
    /// DA block headers the soft confirmations was constructed on.
    pub da_block_headers_of_soft_confirmations: VecDeque<Vec<Da::BlockHeader>>,
    /// Sequencer soft confirmation public key.
    pub sequencer_public_key: Vec<u8>,
    /// Sequencer DA public_key: Vec<u8>,
    pub sequencer_da_public_key: Vec<u8>,
    /// The range of sequencer commitments that are being processed.
    /// The range is inclusive.
    pub sequencer_commitments_range: (u32, u32),
}

impl<StateRoot: borsh::BorshSerialize, Witness: borsh::BorshSerialize, Da: DaSpec> BorshSerialize
    for BatchProofCircuitInputV1<StateRoot, Witness, Da>
{
    /// Pre fork 1 serialization
    /// An additional [u8; 32] is added to the end of the bitcoin da header
    /// So the genesis fork guest fails to deserialize the header
    /// So we remove the last 32 bytes of the header while serializing
    /// This means Genesis 1 seraialization is not compatible with Mock DA
    fn serialize<W: borsh::io::Write>(&self, writer: &mut W) -> borsh::io::Result<()> {
        BorshSerialize::serialize(&self.initial_state_root, writer)?;
        BorshSerialize::serialize(&self.final_state_root, writer)?;
        BorshSerialize::serialize(&self.initial_batch_hash, writer)?;

        // We write each blob tx as serialized into v1
        BorshSerialize::serialize(&(self.da_data.len() as u32), writer)?;
        for blob in &self.da_data {
            let bytes = blob.serialize_v1()?;
            writer.write_all(&bytes)?;
        }

        // remove last 32 bytes
        let original = borsh::to_vec(&self.da_block_header_of_commitments)?;
        writer.write_all(&original[..original.len() - 32])?;
        BorshSerialize::serialize(&self.inclusion_proof, writer)?;
        BorshSerialize::serialize(&self.completeness_proof, writer)?;
        BorshSerialize::serialize(&self.preproven_commitments, writer)?;
        BorshSerialize::serialize(&self.soft_confirmations, writer)?;
        BorshSerialize::serialize(&self.state_transition_witnesses, writer)?;

        // for every Da::BlockHeader we serialize it and remove last 32 bytes
        writer
            .write_all(&(self.da_block_headers_of_soft_confirmations.len() as u32).to_le_bytes())?;
        for header_vec in &self.da_block_headers_of_soft_confirmations {
            writer.write_all(&(header_vec.len() as u32).to_le_bytes())?;
            for header in header_vec {
                let original = borsh::to_vec(header)?;
                writer.write_all(&original[..original.len() - 32])?;
            }
        }

        BorshSerialize::serialize(&self.sequencer_public_key, writer)?;
        BorshSerialize::serialize(&self.sequencer_da_public_key, writer)?;
        BorshSerialize::serialize(&self.sequencer_commitments_range, writer)?;

        Ok(())
    }
}

impl<'txs, StateRoot, Witness, Da, Tx>
    From<BatchProofCircuitInput<'txs, StateRoot, Witness, Da, Tx>>
    for BatchProofCircuitInputV1<StateRoot, Witness, Da>
where
    Da: DaSpec,
    Tx: Clone,
    StateRoot: Serialize + DeserializeOwned,
    Witness: Serialize + DeserializeOwned,
{
    fn from(input: BatchProofCircuitInput<'txs, StateRoot, Witness, Da, Tx>) -> Self {
        BatchProofCircuitInputV1 {
            initial_state_root: input.initial_state_root,
            final_state_root: input.final_state_root,
            initial_batch_hash: input.prev_soft_confirmation_hash,
            da_data: input.da_data,
            da_block_header_of_commitments: input.da_block_header_of_commitments,
            inclusion_proof: input.inclusion_proof,
            completeness_proof: input.completeness_proof,
            preproven_commitments: input.preproven_commitments,
            soft_confirmations: input
                .soft_confirmations
                .into_iter()
                .map(|confirmations| {
                    confirmations
                        .into_iter()
                        .map(SignedSoftConfirmationV1::from)
                        .collect()
                })
                .collect(),
            state_transition_witnesses: input
                .state_transition_witnesses
                .into_iter()
                .map(|witnesses| witnesses.into_iter().map(|(witness, _)| witness).collect())
                .collect(),
            da_block_headers_of_soft_confirmations: input.da_block_headers_of_soft_confirmations,
            sequencer_public_key: input.sequencer_public_key,
            sequencer_da_public_key: input.sequencer_da_public_key,
            sequencer_commitments_range: input.sequencer_commitments_range,
        }
    }
}

/// The batch proof that was not verified in the light client circuit because it was missing another proof for state root chaining
/// This struct is passed as an output to the light client circuit
/// After that the new circuit will read that info to update the state root if possible
#[derive(Debug, Clone, BorshDeserialize, BorshSerialize, PartialEq, Serialize, Deserialize)]
pub struct BatchProofInfo {
    /// Initial state root of the batch proof
    pub initial_state_root: [u8; 32],
    /// Final state root of the batch proof
    pub final_state_root: [u8; 32],
    /// The last processed l2 height in the batch proof
    pub last_l2_height: u64,
}

impl BatchProofInfo {
    /// Create a new `BatchProofInfo` instance.
    pub fn new(
        initial_state_root: [u8; 32],
        final_state_root: [u8; 32],
        last_l2_height: u64,
    ) -> Self {
        Self {
            initial_state_root,
            final_state_root,
            last_l2_height,
        }
    }
}

/// The output of light client proof
#[derive(Debug, Clone, BorshDeserialize, BorshSerialize, PartialEq)]
pub struct LightClientCircuitOutput {
    /// State root of the node after the light client proof
    pub state_root: [u8; 32],
    /// The method id of the light client proof
    /// This is used to compare the previous light client proof method id with the input (current) method id
    pub light_client_proof_method_id: [u32; 8],
    /// Latest da state output of the previous light client proof
    /// If None, initial hardcoded da block will be used for verification
    pub latest_da_state: LatestDaState,
    /// Batch proof info from current or previous light client proofs that were not changed and unable to update the state root yet
    pub unchained_batch_proofs_info: Vec<BatchProofInfo>,
    /// Last l2 height the light client proof verifies
    pub last_l2_height: u64,
    /// L2 activation height of the fork and the Method ids of the batch proofs that were verified in the light client proof
    pub batch_proof_method_ids: Vec<(u64, [u32; 8])>,
    /// A map from tx hash to chunk data.
    /// MMRGuest is an impl. MMR, which only needs to hold considerably small amount of data.
    /// like 32 hashes and some u64
    pub mmr_guest: MMRGuest,
}

/// The input of light client proof
#[derive(BorshDeserialize, BorshSerialize)]
pub struct LightClientCircuitInput<Da: DaSpec> {
    /// The `crate::da::DaData` that are being processed as blobs.
    pub da_data: Vec<Da::BlobTransaction>,
    /// The inclusion proof for all DA data.
    pub inclusion_proof: Da::InclusionMultiProof,
    /// The completeness proof for all DA data.
    pub completeness_proof: Da::CompletenessProof,
    /// DA block header that the batch proofs were found in.
    pub da_block_header: Da::BlockHeader,
    /// Light client proof method id
    pub light_client_proof_method_id: [u32; 8],
    /// Light client proof output
    /// Optional because the first light client proof doesn't have a previous proof
    pub previous_light_client_proof_journal: Option<Vec<u8>>,
    /// Hints for the guest MMR tree.
    pub mmr_hints: VecDeque<(MMRChunk, MMRInclusionProof)>,
    /// Hint for which proofs are expected to fail
    ///
    /// Note: Indices are u32 even though we don't expect that many proofs
    /// on a DA block. However storing them as u32 is more efficient in zkVMs
    /// and just to be sure we don't overflow u8.
    pub expected_to_fail_hint: Vec<u32>,
}

#[cfg(feature = "std")]
/// A cryptographic commitment to the contents of this storage
pub type StorageRootHash = jmt::RootHash;

#[cfg(not(feature = "std"))]
/// To bypass nostd builds.
pub type StorageRootHash = Vec<u8>;

#[cfg(feature = "std")]
/// Alias to jmt::proof::SparseMerkleProof.
pub type SparseMerkleProofSha2 = jmt::proof::SparseMerkleProof<sha2::Sha256>;

#[cfg(not(feature = "std"))]
/// To bypass nostd builds.
pub type SparseMerkleProofSha2 = Vec<u8>;
